# Linux手册

## 常用命令

### 查看系统信息

```
# 总核数 = 物理CPU个数 X 每颗物理CPU的核数 
# 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数
 
# 查看物理CPU个数
cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l
 
# 查看每个物理CPU中core的个数(即核数)
cat /proc/cpuinfo | grep "cpu cores" | uniq
 
# 查看逻辑CPU的个数
cat /proc/cpuinfo | grep "processor" | wc -l
```



### ll 信息详解

**文件类型：**

```
“-”表示普通文件；“d”表示目录；“l”表示链接文件；“p”表示管理文件；“b”表示块设备文件；“c”表示字符设备文件；“s”表示套接字文件；
```
**权限：**

```​
其属性可分为三段：[rwx][rwx][r-x]，其中：
    第一段表示文件创建者/所有者对该文件所具有的权限;
    第二段表示创建者/所有者所在的组的其他用户所具有的权限;
    第三段表示其他组的其他用户所具有的权限。

r（Read，读取权限）：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。
w（Write，写入权限）：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。
x（eXecute，执行权限）：对文件而言，具有执行文件的权限；对目录来说，该用户具有进入目录的权限。

另外，这里还有2个很特殊的属性，平时不怎么常见，这里也顺带解释一下：
    s或S（SUID,Set UID）：可执行的文件搭配这个权限，便能得到特权，任意存取该文件的所有者能使用的全部系统资源。请注意具备SUID权限的文件，黑客经常利用这种权限，以SUID配上root帐号拥有者，无声无息地在系统中开扇后门，供日后进出使用。
    t或T（Sticky）：/tmp和 /var/tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。
```
**目录/链接个数**

对于目录文件，表示它的第一级子目录的个数。注意此处看到的值要减2才等于该目录下的子目录的实际个数。这是因为要去掉.目录和..目录。在linux下，.目录表示当前目录，..目录表示上一级目录。

对于其他文件，表示指向它的链接文件的个数。

**所有者/用户组**

表示该文件的所有者/创建者（owner）及其所在的组（group）。

**其他**

带‘*’的文件是linux系统下用于标记可执行文件的一种方式。

### ps 信息详解



### top 选项及输出信息详解

![image-20200227155436241](F:\MINE\doc\Linux\images\Linux使用手册\image-20200227155436241.png)

#### 相关选项

> * -c ： 命令行/程序名切换
> * -d ： 延迟时间间隔为：-d 秒数。小数秒钟将被允许，但不允许使用负数。然而，在所有情况下，如果top在安全模式下运行，则禁止这样的更改，除了root。
> * -H :  线程模式操作。指示显示单个线程。如果没有此命令行选项，将显示每个进程中所有线程的总和。
> * -p： Monitor-PIDs模式为：-pN1 -pN2 ...或-pN1，N2，N3 ...仅监视具有指定进程ID的进程。此选项最多可以给出20次，或者您可以提供最多20个字符的逗号分隔列表。允许合并两种方法。

#### 统计信息区前五行

top命令输出结果中，统计信息区前五行是系统整体的统计信息。
 第一行是任务队列信息，同 uptime 命令的执行结果。其内容如下：

| 符号                           | 含义                                                         |
| :----------------------------- | :----------------------------------------------------------- |
| 18:52:04                       | 当前时间                                                     |
| up 10days, 3:49                | 系统运行时间，格式为：天，时:分                              |
| 1 user                         | 当前登录用户数                                               |
| load average: 0.00, 0.01, 0.05 | 系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值 |

第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行。内容如下：

|   符号   | 含义                                          |
| :------: | :-------------------------------------------- |
|  total   | 进程总数                                      |
| running  | 正在运行的进程数                              |
| sleeping | 睡眠的进程数                                  |
| stopped  | 停止的进程数                                  |
|  zombie  | 僵尸进程数                                    |
| %Cpu(s)  |                                               |
|  0.0 us  | 用户空间占用CPU百分比                         |
|  0.1 sy  | 内核空间占用CPU百分比                         |
|  0.0 ni  | 用户进程空间内改变过优先级的进程占用CPU百分比 |
| 98.7 id  | 空闲CPU百分比;                                |
|  0.0 wa  | 等待输入输出的CPU时间百分比                   |
|  0.0 hi  | 硬件CPU中断占用百分比                         |
|  0.0 si  | 软中断占用百分比                              |
|  0.0 st  | 虚拟机占用百分比                              |

最后两行为内存信息。内容如下：

|         符号         | 含义                                                         |
| :------------------: | :----------------------------------------------------------- |
|       KiB Mem        |                                                              |
|    7993560 total     | 物理内存总量                                                 |
|     207064 free      | 空闲内存总量                                                 |
|     723688 used      | 使用的物理内存总量                                           |
| 7062808 buffer/cache | 用作内核缓存的内存量                                         |
|       KiB Swap       |                                                              |
|    8257532 total     | 交换区总量                                                   |
|     8257356 free     | 空闲交换区总量                                               |
|       176 used       | 使用的交换区总量                                             |
|  6479580  avail Mem  | 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入 |

进程信息区统计信息区域的下方显示了各个进程的详细信息。首先来认识一下各列的含义。

| 序号 | 列名    | 含义                                                         |
| :--: | :------ | :----------------------------------------------------------- |
|  a   | PID     | 进程id                                                       |
|  b   | PPID    | 父进程id                                                     |
|  c   | RUSER   | Real user name                                               |
|  d   | UID     | 进程所有者的用户id                                           |
|  e   | USER    | 进程所有者的用户名                                           |
|  f   | GROUP   | 进程所有者的组名                                             |
|  g   | TTY     | 启动进程的终端名。不是从终端启动的进程则显示为 ?             |
|  h   | PR      | 优先级                                                       |
|  i   | NI      | nice值。负值表示高优先级，正值表示低优先级                   |
|  j   | P       | 最后使用的CPU，仅在多CPU环境下有意义                         |
|  k   | %CPU    | 上次更新到现在的CPU时间占用百分比                            |
|  l   | TIME    | 进程使用的CPU时间总计，单位秒                                |
|  m   | TIME+   | 进程使用的CPU时间总计，单位1/100秒                           |
|  n   | %MEM    | 进程使用的物理内存百分比                                     |
|  o   | VIRT    | 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES                |
|  p   | SWAP    | 进程使用的虚拟内存中，被换出的大小，单位kb。                 |
|  q   | RES     | 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA    |
|  r   | CODE    | 可执行代码占用的物理内存大小，单位kb                         |
|  s   | DATA    | 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb    |
|  t   | SHR     | 共享内存大小，单位kb                                         |
|  u   | nFLT    | 页面错误次数                                                 |
|  v   | nDRT    | 最后一次写入到现在，被修改过的页面数。                       |
|  w   | S       | 进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程) |
|  x   | COMMAND | 命令名/命令行                                                |
|  y   | WCHAN   | 若该进程在睡眠，则显示睡眠中的系统函数名                     |
|  z   | Flags   | 任务标志，参考 sched.h                                       |

默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。

- 更改显示内容
   通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。
- 更改列显示顺序
   按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。
- 按列排序
   按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。



### 查看文件是否拥有软链接或硬链接

**硬链接**

```
- 查找文件可以利用find命令。
- 硬链接的特性，不会跨文件系统，所以源文件在哪个文件系统中，就在那里找
- 硬链接文件和源文件具有相同的inode号，可以利用find的-inum参数和-samefile参数来查找。
- -inum参数表示按照inode号去查找，首先要查看文件的inode号(ll -i)
- -samefile参数表示查找和某个文件相同的inode的文件，不用查看文件的inode号
```

```bash
[root@lixin oldboy]# stat oldboy.txt  //获取文件的inode号码
  File:`oldboy.txt'
  Size:55              Blocks: 8          IO Block: 4096   regular file
Device: 803h/2051d      Inode: 148677      Links: 2
Access: (0644/-rw-r--r--)  Uid: (   0/    root)   Gid: (   0/    root)
Access: 2016-04-17 15:32:13.861206307 +0800
Modify: 2016-04-17 14:20:13.246213893 +0800
Change: 2016-04-17 16:04:17.023206128 +0800
[root@lixin oldboy]# find / -inum 1486772>/dev/null //根据Inode号码查找，把错误提示丢弃
/usr/local/xiaoming
/data/oldboy/oldboy.txt
[root@lixin oldboy]#
```



**软连接**

  ```
- 软链接可以跨文件系统，并且inode、属性都和源文件的不同没有规律可以寻
- 当我们使用ls –l命令查看链接文件的时候，它都会以：filename -> link filename方式显示。
- 我们寻找当前系统内所有的链接文件，然后过滤我们要找的源文件名n，就能查看有哪些文件指向了源文件。
  ```

```bash
[root@lixin oldboy]# find -type l -exec ls -l {} \;        
lrwxrwxrwx 1 root root 1 Apr 17 16:21 ./xiaohong-> 1
lrwxrwxrwx 1 root root 10 Apr 17 16:16./oldgirl.txt -> oldboy.txt
[root@lixin oldboy]#    //找到文件后，长格式显示，然后过滤源文件名
[root@lixin oldboy]# find -type l -exec ls -l {}\;| grep 'oldboy.txt'
lrwxrwxrwx 1 root root 10 Apr 17 16:16./oldgirl.txt -> oldboy.txt
```





## 必须懂的

### 软连接和硬链接

在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个inode 索引节点。

- **软连接**  软链接产生的是一个新的文件，但这个文件的作用就是专门指向某个文件的，删了这个软连接文件，那就等于不需要这个连接，和原来的存在的实体原文件没有任何关系，但删除原来的文件，则相应的软连接不可用（cat那个软链接文件，则提示“没有该文件或目录“）。

  软连接可以对目录连接，硬链接不可以。

- **硬连接** 硬链接是不会建立inode的，他、只是在文件原来的inode link count域再增加1而已，也因此硬链接是**不可以跨越文件系统**的。相反是软连接会重新建立一个inode，当然inode的结构跟其他的不一样，只是一个指明源文件的字符串信息。一旦删除源文件，那么软连接将变得毫无意义。而硬链接删除的时候，系统调用会检查inode link count的数值，如果他大于等于1，那么inode不会被回收。因此文件的内容不会被删除，类似于引用计数的概念。可以通过ls -i来查看一下，这两个文件的inode号是同一个，说明它们是同一个文件。

- 软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）；

- 软连接可以对目录连接，硬链接不可以。

- 两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。

  ```
  ln [参数] [源文件或目录] [目标文件或目录]
  -s 软链接(符号链接)	-f 强制执行		-v 显示详细的处理过程    
  -n 将指向目录的链接视为普通文件
  ```

```bash
$ mkdir foo1 foo2
$ ln -s foo1 bar
$ ls -l bar
  lrwxrwxrwx 1 drew users 4 Sep 17 12:51 bar -> foo1
$ ln -sf foo2 bar
$ ls -l bar
  lrwxrwxrwx 1 drew users 4 Sep 17 12:51 bar -> foo1
$ ls -l foo1
  total 0
  lrwxrwxrwx 1 drew users 4 Sep 17 12:51 foo2 -> foo2
$ ln -snf foo2 bar
$ ls -l bar
  lrwxrwxrwx 1 drew users 4 Sep 17 12:52 bar -> foo2
```





### 孤儿进程和僵尸进程

**孤儿进程**

​        在操作系统领域中，孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程。这些孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵尸进程**

​		在UNIX 系统中，一个进程结束了，但是他的父进程没有等待(调用wait / waitpid)他， 那么他将变成一个僵尸进程。

​        在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）。直到父进程通过wait / waitpid来取时才释放. 但这样就导致了问题，如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进城，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。